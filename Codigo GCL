(*
=========================================================
Recomendador con m√∫ltiples perfiles ‚Äî Pseudoc√≥digo GCL
=========================================================
*)

const TOP_N := 5;

(*
Estructuras base
- CATALOG: conjunto de items con campos title: String,
           genres: Set<String>, tags: Set<String>, popularity: Int
- USERS:   mapa usuario -> Lista<String> (historial, t√≠tulos vistos)
*)

var CATALOG, USERS;

(*
Inicializaci√≥n de CATALOG (id√©ntica al c√≥digo Python; abreviada aqu√≠ por espacio.
En tu documento final, copia todas las entradas tal como est√°n en el script).
Ejemplo de una entrada:

CATALOG := {
  item("Toy Story", {"comedy","family","adventure"}, {"toys","friendship","pixar"}, 950),
  item("Matrix", {"action","scifi"}, {"virtual","rebellion","classic"}, 990),
  ...
  item("WALL-E", {"animation","scifi","family"}, {"robot","earth","pixar"}, 950)
};

USERS := {
  ("ana" -> ["Toy Story","Coco","Inside Out","Soul"]),
  ("luis" -> ["Matrix","Inception","Spider-Verse"]),
  ...
  ("natalia" -> ["Coco","Inside Out","WALL-E"])
};
*)

(*
=================================
Utilidades de b√∫squeda y helpers
=================================
*)

fun FindItemByTitle(t) =
  var found;
  found := nil;
  do ‚àÉc ‚àà CATALOG : c.title = t ->
      found := c;
      exit
  od;
  return found;

fun SetFromList(L) =
  var S; S := {};
  do ‚àÉx ‚àà L : x ‚àâ S ->
      S := S ‚à™ {x};
      L := L \ {x}
  od;
  return S;

fun Tail(L, k) =
  (* devuelve la ‚Äúcola‚Äù de los √∫ltimos k elementos de la lista L *)
  var R; R := [];
  var n, i; n := length(L);
  i := max(1, n - k + 1);
  do i ‚â§ n ->
      R := R ‚ß∫ [L[i]];
      i := i + 1
  od;
  return R;

(*
========================
Mapa estado ‚Üí g√©neros
========================
*)

proc MoodToGenres(MOOD) -> MOOD_GENRES =
  if
    MOOD = "üòä" -> MOOD_GENRES := {"comedy","adventure"}
  []
    MOOD = "üòî" -> MOOD_GENRES := {"comedy","family","feelgood"}
  []
    MOOD = "üòê" -> MOOD_GENRES := {"popular","mixed"}
  []
    MOOD = "üò°" -> MOOD_GENRES := {"action","thriller"}
  []
    MOOD = "üò¥" -> MOOD_GENRES := {"short","relax"}
  []
    MOOD = "ü§©" -> MOOD_GENRES := {"new","scifi","action"}
  fi;

(*
========================
Similitud y contadores
========================
*)

fun Jaccard(A, B) =
  if (A ‚à™ B) = {} -> return 0 fi;
  return |A ‚à© B| / |A ‚à™ B|;

proc CountAddSet(var CNT, KSET) =
  (* CNT: mapa kw -> frecuencia; KSET: conjunto de keywords *)
  do ‚àÉk ‚àà KSET ->
     if k ‚àà dom(CNT) -> CNT[k] := CNT[k] + 1
     [] k ‚àâ dom(CNT) -> CNT[k] := 1
     fi;
     KSET := KSET \ {k}
  od;

fun TopK(CNT, k) =
  (* devuelve conjunto con las k claves de mayor frecuencia *)
  var RES; RES := {};
  var TMP; TMP := CNT;       (* copia l√≥gica *)
  var mkey, mval;
  do (k > 0) ‚àß (dom(TMP) ‚â† {}) ->
     (* extrae la clave con mayor valor *)
     mkey := any x ‚àà dom(TMP) : ‚àÄy ‚àà dom(TMP) ‚Ä¢ TMP[x] ‚â• TMP[y];
     RES := RES ‚à™ {mkey};
     TMP := TMP \ {mkey};
     k := k - 1
  od;
  return RES;

(*
========================
Perfiles del usuario
========================
*)

proc BuildProfiles(HISTORY, K_LONG, K_RECENT) -> PROFILE_LONG, PROFILE_RECENT =
  var CNT_LONG, CNT_REC; CNT_LONG := {}; CNT_REC := {};
  var title, it;

  (* Contar sobre todo el historial *)
  do ‚àÉtitle ‚àà SetFromList(HISTORY) ->
     it := FindItemByTitle(title);
     if it ‚â† nil ->
        call CountAddSet(CNT_LONG, it.genres ‚à™ it.tags)
     fi;
     HISTORY := HISTORY \ {title}
  od;

  (* Contar sobre √∫ltimos K_RECENT *)
  var LAST; LAST := Tail(HISTORY, K_RECENT);
  do ‚àÉtitle ‚àà SetFromList(LAST) ->
     it := FindItemByTitle(title);
     if it ‚â† nil ->
        call CountAddSet(CNT_REC, it.genres ‚à™ it.tags)
     fi;
     LAST := LAST \ {title}
  od;

  PROFILE_LONG := TopK(CNT_LONG, K_LONG);
  PROFILE_RECENT := TopK(CNT_REC, K_RECENT);

(*
========================
Boost por estado de √°nimo
========================
*)

fun MoodBoost(ITEM_GENRES, MOOD_GENRES) =
  var b; b := 0.1 * |ITEM_GENRES ‚à© MOOD_GENRES|;
  if b > 0.3 -> b := 0.3 fi;
  return b;

(*
========================
Explicaci√≥n (texto corto)
========================
*)

fun BuildReason(PROFILE_LONG, PROFILE_RECENT, ITEM, MOOD_GENRES, MOOD) =
  var kw, ol, orc, om, parts;
  kw  := ITEM.genres ‚à™ ITEM.tags;
  ol  := PROFILE_LONG ‚à© kw;
  orc := PROFILE_RECENT ‚à© kw;
  om  := ITEM.genres ‚à© MOOD_GENRES;
  parts := [];

  if ol ‚â† {} ->
     parts := parts ‚ß∫ ["coincide con tus gustos de siempre (" + join(ol, ", ") + ")"]
  fi;
  if orc ‚â† {} ->
     parts := parts ‚ß∫ ["se parece a lo que viste recientemente (" + join(orc, ", ") + ")"]
  fi;
  if om ‚â† {} ->
     parts := parts ‚ß∫ ["va con tu estado de √°nimo " + MOOD + " (" + join(om, ", ") + ")"]
  fi;

  if parts = [] -> return "bien valorada y puede gustarte por variedad" fi;
  return join(parts, "; ");

(*
========================
Puntaje de un √≠tem
========================
*)

fun ScoreItem(ITEM, PROFILE_LONG, PROFILE_RECENT, MOOD_GENRES) =
  var kw, s_long, s_rec, s_mood, s_pop;
  kw     := ITEM.genres ‚à™ ITEM.tags;
  s_long := Jaccard(PROFILE_LONG, kw);
  s_rec  := Jaccard(PROFILE_RECENT, kw);
  s_mood := MoodBoost(ITEM.genres, MOOD_GENRES);
  s_pop  := 0.001 * ITEM.popularity;
  return 0.5*s_long + 0.3*s_rec + s_mood + s_pop;

(*
========================
Recomendar (Top-N)
========================
*)

proc Recommend(HISTORY_LIST, MOOD, TOP_N) -> RECS =
  var PROFILE_LONG, PROFILE_RECENT, MOOD_GENRES, SEEN, SCORED;
  call MoodToGenres(MOOD) -> MOOD_GENRES;
  call BuildProfiles(HISTORY_LIST, 6, 4) -> PROFILE_LONG, PROFILE_RECENT;

  SEEN := SetFromList(HISTORY_LIST);
  SCORED := {};   (* conjunto de tuplas (title, score, reason) *)

  var c, s, r;
  do ‚àÉc ‚àà CATALOG : c.title ‚àâ SEEN ->
     s := ScoreItem(c, PROFILE_LONG, PROFILE_RECENT, MOOD_GENRES);
     r := BuildReason(PROFILE_LONG, PROFILE_RECENT, c, MOOD_GENRES, MOOD);
     SCORED := SCORED ‚à™ {(c.title, s, r)};
     CATALOG := CATALOG \ {c}
  od;

  (* Ordenar por score descendente y tomar TOP_N *)
  RECS := TopNByScore(SCORED, TOP_N);

(*
========================
Programa principal
========================
*)

begin
  var user_id, mood, history, recs;

  (* Sup√≥n que CATALOG y USERS ya est√°n inicializados con los datos del script. *)

  input user_id;                         (* ej.: "ana" *)
  if user_id ‚àâ dom(USERS) -> user_id := "ana" fi;

  input mood;                            (* ej.: "üòä" *)
  history := USERS[user_id];             (* lista de t√≠tulos vistos *)

  call Recommend(history, mood, TOP_N) -> recs;

  output "=== Recomendaciones (TOP " + toString(TOP_N) + ") para " + user_id + " (" + mood + ") ===";
  (* Imprimir cada (title, score, reason) en recs *)
  do ‚àÉt ‚àà recs ->
     output t;           (* donde t = (title, score, reason) *)
     recs := recs \ {t}
  od
end
